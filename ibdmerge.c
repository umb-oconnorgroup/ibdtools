/* 
 * ibdmerge:
 * 	merge overlapping or nearby IBDs due to 
 * 	1. different haplotype combination of each sample pair.
 * 		- id1 hap1 id2 hap1
 * 		- id1 hap1 id2 hap2
 * 		- id1 hap2 id2 hap1
 * 		- id1 hap2 id2 hap2
 * 	2. phasing errors or genotyping erros can cause breaks
 * 	and gaps in detected ibd. See desription of the
 * 	`merge-ibd-segments.jar` from RefineIBd website.
 * 	http://faculty.washington.edu/browning/refined-ibd.html
 * 	They remove gaps between IBD segments that
 * 		- have at most one discordant homozygote (max_snp)
 * 		- are less than 0.6 cM in length (max_cM)
 *
 * Input: 
 * 	1. Sorted IBD output (from stdin) which has four columns:
 * 		- col1: `id1:id2` where strcmp(id1, id2) < 0.
 * 		- col2: `start` in bp
 * 		- col3: `end` in bp
 * 		- col4: `cM` length of IBD segments.
 * 	2. 1st argument: ibdmap file generated by `ibdmap`
 * 		- col1: snp position in bp
 * 		- col2: snp position in cM (calculated)
 * 	3. Optional arguments: max_snp and max_cM as described above.
 *
 * Output: merged IBD with a similar format as input IBD.
 */

#include <assert.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int
str_cmp(const void *str1, const void *str2)
{
    return strcmp((char *) str1, (char *) str2);
}

int
size_cmp(const void *size1, const void *size2)
{
    if (*((size_t *) size1) > *((size_t *) size2))
        return 1;
    else if (*((size_t *) size1) < *((size_t *) size2))
        return -1;
    else
        return 0;
}

typedef struct {
    char sample_pair[1000];
    size_t start;
    size_t end;
    double len_cM;
} ibdrec_t;

typedef struct {
    size_t *bp;
    double *cM;
    size_t nmemb;
} ibdmap_t;

typedef struct {
    ibdmap_t maps;
    ibdrec_t r1, r2;
    double merge_max_cM;
    int merge_max_num_snp;
} ibd_t;

void
ibd_read_map(ibd_t *self, char *mapfilename)
{

    size_t *bp = NULL;
    double *cM = NULL;
    size_t ncap = 0;
    size_t nmemb = 0;
    char *tok = NULL;

    char buff[1000], *p = buff;
    size_t buff_size = 1000;
    FILE *fp = fopen(mapfilename, "r");
    assert(fp != NULL && "Can't open ibdmapfile!");

    // get size info
    while (getline(&p, &buff_size, fp) > 0 && *p != '\n')
        ncap++;

    // alloc memeory
    bp = calloc(ncap, sizeof(*bp));
    cM = calloc(ncap, sizeof(*cM));
    assert(bp != NULL && "cannot alloc memeory!");
    assert(cM != NULL && "cannot alloc memeory!");

    // get actual positions
    fseek(fp, 0, SEEK_SET);
    while (getline(&p, &buff_size, fp) > 0 && *p != '\n') {
        tok = strtok(p, " \t\n"); // bp, long
        assert(tok != NULL && "ibdmapfile format error!");
        bp[nmemb] = strtol(tok, NULL, 10);
        tok = strtok(NULL, " \t\n"); // cM, double
        assert(tok != NULL && "ibdmapfile format error!");
        cM[nmemb] = strtod(tok, NULL);
        nmemb++;
    }

    fclose(fp);
    fp = NULL;

    // update self
    self->maps.bp = bp;
    bp = NULL;
    self->maps.cM = cM;
    cM = NULL;
    self->maps.nmemb = nmemb;
}

void
ibd_merge(ibd_t *self)
{
    ibdrec_t *rc = &self->r1;
    ibdrec_t *rn = &self->r2;
    ibdrec_t *rp = NULL;

    ibdmap_t *maps = &self->maps;

    char buff[1000], *p = buff, *tok = NULL;
    size_t buff_size = 1000;
    int need_merge = 0;
    double deltaCM = 0;

    size_t *p_bp = NULL, index1 = 0, index2 = 0;
    size_t count = 0;

    while (getline(&p, &buff_size, stdin) > 0 && *p != '\n') {
        tok = strtok(p, "\t\n");
        assert(tok != NULL && "ibd record format error");
        strcpy(rn->sample_pair, p);
        tok = strtok(NULL, "\t\n");
        assert(tok != NULL && "ibd record format error");
        rn->start = strtol(tok, NULL, 10);
        tok = strtok(NULL, "\t\n");
        assert(tok != NULL && "ibd record format error");
        rn->end = strtol(tok, NULL, 10);
        tok = strtok(NULL, "\t\n");
        assert(tok != NULL && "ibd record format error");
        rn->len_cM = strtod(tok, NULL);
        count++;

        /* 1. new start */
        if (count == 1) {
            rp = rn;
            rn = rc;
            rc = rp;
            continue;
        }

        /* 2. not same sample pair, no merge, print */
        if (strcmp(rc->sample_pair, rn->sample_pair) != 0) {
            printf(
                "%s\t%ld\t%ld\t%.4f\n", rc->sample_pair, rc->start, rc->end, rc->len_cM);
            rp = rn;
            rn = rc;
            rc = rp;
            continue;
        }

        /* otherwise need to  find position indices for rc.end, rn.start */
        p_bp = (size_t *) bsearch(
            &rc->end, maps->bp, maps->nmemb, sizeof(*maps->bp), size_cmp);
        assert(p_bp != NULL && "can't find position in ibdmapfile");
        index1 = p_bp - maps->bp;

        p_bp = (size_t *) bsearch(
            &rn->start, maps->bp, maps->nmemb, sizeof(*maps->bp), size_cmp);
        assert(p_bp != NULL && "can't find position in ibdmapfile");
        index2 = p_bp - maps->bp;

        deltaCM = maps->cM[index2] - maps->cM[index1];

        /* 3. overlapping, cM shrinking, no printing */
        if (index2 <= index1) {
            /* if(rc->end >= rn->end) no change because rc contains the whole rn
             */
            if (rc->end < rn->end) {
                rc->len_cM += rn->len_cM + deltaCM; /* deltaCM is negative */
                rc->end = rn->end;
            }
            continue;
        }

        /* 4. not overlapping but close enough, merge, no printing */
        if (index2 - index1 <= self->merge_max_num_snp
            && deltaCM <= self->merge_max_cM) {
            rc->len_cM += deltaCM; /* deltaCM is positive */
            rc->end = rn->end;
        }
        /* 5. too far away, no merging, printing */
        else {
            printf(
                "%s\t%ld\t%ld\t%.4f\n", rc->sample_pair, rc->start, rc->end, rc->len_cM);
            rp = rn;
            rn = rc;
            rc = rp;
        }
    }
    /* print last  record stored in rc */
    printf("%s\t%ld\t%ld\t%.4f\n", rc->sample_pair, rc->start, rc->end, rc->len_cM);
}

int
main(int argc, char *argv[])
{
    ibd_t ibd;
    char *usage = " zcat xxx.ibd.gz | ./ibdmerg ibdmap.txt"
                  " [<merge_max_num_snp> <merge_max_cM>] > out.ibd";
    if (argc < 2) {
        fprintf(stderr, "\n%s\n", usage);
        exit(-1);
    }

    if (argc == 4) {
        ibd.merge_max_num_snp = atoi(argv[2]);
        ibd.merge_max_cM = strtod(argv[3], NULL);
    } else {
        ibd.merge_max_num_snp = 1;
        ibd.merge_max_cM = 0.6;
    }

    ibd_read_map(&ibd, argv[1]);
    ibd_merge(&ibd);

    return 0;
}
