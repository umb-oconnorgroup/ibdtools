/*
 * ibdsum2:
 * 	Calculate the sample-pair genome-wide total IBD length (cM).  The code
 * 	assumes and takes advantage of the input file being sorted and
 * 	non-overlapping (merged).  Each chromsome has a current id pairs being
 * 	processed. The `smallest` id-pair of all current pairs will be printed
 * 	together with a total IBD value by summing up IBD of this pair in
 * 	different regions of the same chromsome as well as across all the
 * 	chromsomes.
 *
 * 	The order of current id-pairs of different chromsomes is maintained by
 * 	an array-based linked list.
 *
 * Input:
 * 	Sorted and merged IBD files compressed in .gz format which are
 * 	generated by `ibdmerge`
 * 	It has 4 columns
 * 	- col1: `id1:id2`
 * 	- col2: `start` in bp
 * 	- col3: `end` in bp
 * 	- col4: `cM` IBD length in cM.
 *
 * Output:
 * 	two-column table printed to stdout
 * 	- col1: `id1:id2`
 * 	- col2: genome-wide total IBD in cM
 */

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <zlib.h>

#define N_CHROM 24
#define cM_COL 4

/* inline version of strcmp */
static inline int
strcmp_i(const char *a, const char *b)
{
    while (1) {
        if (*a != *b)
            return *a - *b;
        else {
            if (*a == '\0')
                return 0;
            ++a;
            ++b;
        }
    }
}

typedef struct {
    char *name;
    float value;
} rec_t;

int
rec_cmp_v(const void *a1, const void *b1)
{
    const char *a = ((rec_t *) a1)->name;
    const char *b = ((rec_t *) b1)->name;
    return strcmp_i(a, b);
}

typedef struct {
    gzFile gzf;
    char *buff;
    char *next;
    char *trail; /*counted from the next char after the last '\n' or '\0' */
    size_t buffsize;
    char str1[256];   /* temp save rec_t names */
    char str2[256];
    rec_t *r1, *r2;
    int eof;
} gzbuff_t;

void
gzbuff_init(gzbuff_t *self, size_t buffsize, char *gzFilename)
{
    self->buff = malloc(sizeof(*self->buff) * buffsize);
    assert(self->buff != NULL && "can not alloc memory");
    self->buff[0] = '\0';
    self->buffsize = buffsize;
    self->trail = NULL;
    self->eof = 0;
    self->next = 0;
    self->gzf = gzopen(gzFilename, "r");
    assert(self->gzf != Z_NULL && "gzopen error");
}

void
gzbuff_free(gzbuff_t *self)
{
    if (self->buff) {
        free(self->buff);
        self->buff = NULL;
    }
}

/* read with trailing string recycled, manually add '\0' to the end,
 * return -1 if can not read; return nread if can read */
int
gzbuff_read_chunck(gzbuff_t *self)
{
    char *p1, *p2;
    int nread;

    if (self->eof)
        return -1;

    /* Back up names. As the current and next rect names are pointers to the
     * buffer, when gzbuff is refreshed after reading new chuck of data, it is
     * necessary to back up the pointed string to avoid the rect name pointed
     * to random characters in the refeshed buffer. */
    if (self->r1->name) {
        strncpy(self->str1, self->r1->name, 256);
        self->r1->name = self->str1;
    }
    if (self->r2->name) {
        strncpy(self->str2, self->r2->name, 256);
        self->r2->name = self->str2;
    }

    p1 = self->buff;
    /* recycle trailing string */
    if(self->trail){
    	p2 = self->trail;
	while(*p2!='\0'){
    	    *(p1++) = *(p2++);
	}
	assert(p2 < self->buff + self->buffsize);
    }

    /* read and append file contents to buffer */
    nread = gzread(self->gzf, p1, self->buff + self->buffsize - p1 - 1);
    assert(nread>=0 && "gzread error");
    *(p1 + nread) = '\0';
    if ( nread < self->buff + self->buffsize - p1 - 1)
        self->eof = 1;

    /* identify the trailing position */
    p2 = p1 + nread;
    while (p2 > self->buff && *p2 != '\n') {
        --p2;
    }
    if (p2 == self->buff) {
        p2 = p1 + nread;
	self->trail = NULL;
    }
    else{
        *p2 = '\0';
    	++p2;
    	self->trail = p2;
    }

    /* reset next pointer */
    self->next = self->buff;

    return nread;
}

static inline void
gzbuff_read_rec(gzbuff_t *self, rec_t *prec)
{
    int nread;
    char *p1, *p2;
    /* read chunck if needed */
    if (self->buff[0] == '\0' || self->next == NULL) {
        nread = gzbuff_read_chunck(self);
        if (nread < 0) {
	    fprintf(stderr, "nread= %d, iseof=%d\n", nread, self->eof);
            prec->name = NULL;
            return;
        }
        assert(self->next == self->buff);
    }

    /* read records and shift self->next */
    p1 = self->next;

    /*** find tabs: if value on 4th column, find tabs for three times */
    for (int i = 0; i < cM_COL - 1; ++i) {
        while (*(++p1) != '\t')
	{
            assert(*p1 != '\0' && "no tab found");
	}
        *p1 = '\0';
        prec->name = self->next;
	assert(prec->name[0] != '\n');
        ++p1;
    }
    /*** find newline or end */
    for (p2 = p1; *p2 != '\0' && *p2 != '\n'; ++p2)
        ;
    if (*p2 == '\n') {
        *p2 = '\0';
        self->next = p2 + 1;
    } else { /* *p2 == '\0' */
        self->next = NULL;
    }
    prec->value = strtof(p1, NULL);
    assert(prec->value > -1 && "read cM value less than -1");
    if(self->next) assert(self->next[0] != '\n');
}

static inline int
rec_less(const rec_t *self, const rec_t *other, int *res)
{
    int ret = strcmp(self->name, other->name);
    if (res)
        *res = ret;
    return ret < 0;
}

typedef struct {
    rec_t recs[N_CHROM];
    int nexts[N_CHROM];
    int head;
    rec_t recs_tmp[N_CHROM];
    gzbuff_t buffer[N_CHROM];
    int nbuffer;

} list_t;

static inline void
list_init(list_t *self, gzbuff_t *buffer, int nbuffer)
{
    assert(nbuffer <= N_CHROM && "number of buffers should exceed number of chromsome");
    /* buffers and records */
    for (int i = 0; i < nbuffer; ++i) {
        self->buffer[i] = buffer[i];
        self->nbuffer = nbuffer;
        self->buffer[i].r1 = self->recs + i;
        self->buffer[i].r2 = self->recs_tmp + i;
        self->recs[i].name = NULL;
        self->recs_tmp[i].name = NULL;
        self->head = -1;
        self->nexts[i] = i + 1;
        if (i == nbuffer)
            self->nexts[i] = -1;
        gzbuff_read_rec(self->buffer + i, self->recs_tmp + i);
    }
}

static inline void
list_free(list_t *self)
{
    for (int i = 0; i < self->nbuffer; ++i) {
        gzbuff_free(self->buffer + i);
    }
}

static inline void
list_load(list_t *self, int chr)
{
    gzbuff_t *buff = self->buffer + chr;
    rec_t *r1 = self->recs + chr;
    rec_t *r2 = self->recs_tmp + chr;
    *r1 = *r2;
    int ret;
    if (self->recs[chr].name == NULL)
        return;
    while (1) {
        gzbuff_read_rec(buff, r2);
        if (r2->name == NULL)
            return;
	assert(r2->name[0]!='\n');
        rec_less(r1, r2, &ret);
	assert(ret <=0 && "input file not sorted");
        if (ret < 0)
            return;
        r1->value += r2->value;
    }
}

static inline void
list_insert(list_t *self, int i)
{
    int *n = self->nexts;
    rec_t *recs = self->recs;

    int h = self->head;
    int l = h;
    int r;

    /* if list is empty */
    if (h == -1) {
        self->head = i;
        n[i] = -1;
        return;
    }
    /* if not empty but less than head */
    else if (rec_less(recs + i, recs + h, NULL)) {
        n[i] = h;
        self->head = i;
        return;
    }
    /* if not empty and greater than head*/
    while (1) {
        r = n[l];
	/*** if right one is empty, add to the end */
        if (r == -1) {
            n[l] = i;
            n[i] = -1;
            break;
	/*** if right one is smaller, look at the next */
        } else if (rec_less(recs + r, recs + i, NULL)) {
            l = r;
            continue;
	/*** if right one is larger, insert */
        } else {
            n[l] = i;
            n[i] = r;
            break;
        }
    }
}

static inline int
list_sum(list_t *self)
{
    int i = self->head;
    float sum = 0;
    while (1) {
	assert(self->recs[i].value > -1 && "added value < -1 ");
        sum += self->recs[i].value;
        i = self->nexts[i];
        if (i == -1 || rec_less(self->recs + self->head, self->recs + i, NULL)) {
            break;
        }
    }
    if (self->recs[self->head].name != NULL)
        fprintf(stdout, "%s\t%0.4f\n", self->recs[self->head].name, sum);
    return i;
}

static inline void
list_shift(list_t *self, int i)
{
    int j = self->head;
    self->head = i;
    while (j != i) {
        int k = j;
        j = self->nexts[j];
        list_load(self, k);
        if (self->recs[k].name != NULL)
            list_insert(self, k);
	else {
	    fprintf(stderr, "%d is out, iseof: %d\n",k, self ->buffer[k].eof);
	    self->nexts[k] = -2;
	}
    }
}

int
main(int argc, char *argv[])
{
    char *usage = "Usage: ibdsum *.gz | gzip out.gz";
    if (argc < 2) {
        fprintf(stderr, "%s\n", usage);
        exit(1);
    }

    int nbuffer = argc - 1;

    gzbuff_t *buffs = malloc(sizeof(*buffs) * nbuffer);
    for (int i = 0; i < nbuffer; i++) {
        gzbuff_init(buffs + i, 1000, argv[i + 1]);
    }

    list_t lst;
    list_init(&lst, buffs, nbuffer);

    for (int i = 0; i < nbuffer; i++) {
        list_load(&lst, i);
        list_insert(&lst, i);
    }

    while (lst.head != -1) {
        int i = list_sum(&lst);
        list_shift(&lst, i);

    }
    return 0;
}
